<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autoencoder Visual</title>
    <!-- Enlace a Tailwind CSS CDN para estilos responsivos y modernos -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Enlace a Google Fonts - Inter para una tipografía limpia y profesional -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <!-- Enlace a D3.js CDN para el gráfico interactivo del espacio latente -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <!-- Enlace a math.js CDN para operaciones matemáticas y matriciales -->
    <script src="https://cdn.jsdelivr.net/npm/mathjs@11.8.0/lib/browser/math.min.js"></script>
    <style>
        /* Configuración de fuente personalizada para todo el cuerpo */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Estilos para el spinner de carga, alineado con el diseño de Tailwind */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3b82f6; /* Color azul de Tailwind */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        /* Estilos para el SVG del gráfico, con un diseño que se integra con Tailwind */
        #chart-svg {
            background-color: #f8fafc; /* Tailwind gray-50 */
            border: 1px solid #e2e8f0; /* Tailwind gray-200 */
            border-radius: 0.75rem; /* Tailwind rounded-xl */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1); /* Tailwind shadow-md */
            cursor: crosshair; /* Cambia el cursor para indicar que se puede hacer clic en el gráfico */
        }
        /* Estilos para los grupos de puntos (contienen el texto de las etiquetas) */
        .point-group text {
            fill: #3b82f6; /* Tailwind blue-500 */
            cursor: pointer; /* Cursor de puntero para indicar interactividad */
            font-weight: 600; /* semibold */
            font-size: 1rem; /* base */
            transition: fill 0.2s ease-in-out, font-size 0.2s ease-in-out; /* Transición suave para efectos hover/seleccion */
        }
        /* Estilos al pasar el mouse sobre las etiquetas */
        .point-group text:hover {
            fill: #2563eb; /* Tailwind blue-600 */
        }
        /* Estilos para el texto de la etiqueta seleccionada */
        .selected-text {
            fill: #dc2626; /* Tailwind red-600 */
            font-size: 1.25rem; /* Fuente más grande para el seleccionado */
            font-weight: 800; /* Extra bold */
        }
        /* Estilos para el círculo que representa el punto arbitrario seleccionado */
        .selected-arbitrary-point {
            fill: #dc2626; /* Tailwind red-600 */
            r: 8; /* Radio del círculo */
            transition: r 0.2s ease-in-out; /* Transición suave para el radio */
            pointer-events: none; /* Asegura que no interfiera con otros clics */
        }
        /* Estilos para los ejes del gráfico */
        .axis path,
        .axis line {
            fill: none;
            stroke: #cbd5e1; /* Tailwind slate-300 */
            shape-rendering: crispEdges; /* Renderizado nítido de las líneas */
        }
        .axis text {
            font-size: 0.875rem; /* Tailwind text-sm */
            fill: #475569; /* Tailwind slate-700 */
        }
        /* Estilos para las celdas de la matriz decodificada */
        .matrix-cell {
            width: 30px; /* Ancho de la celda */
            height: 30px; /* Alto de la celda */
            border: 1px solid #e2e8f0; /* Borde de la celda */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .matrix-cell.active {
            background-color: #000; /* Color para celdas "activas" (1) */
        }
        .matrix-cell.inactive {
            background-color: #f0f0f0; /* Color para celdas "inactivas" (0) */
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="bg-white p-8 rounded-xl shadow-lg max-w-2xl w-full border border-gray-200">
        <h1 class="text-4xl font-extrabold text-gray-800 mb-6 text-center">Autoencoder Visual</h1>

        <!-- Selector de Operación: Decodificador o Quitar Ruido -->
        <div class="mb-4">
            <label for="operationSelect" class="block text-gray-700 text-sm font-semibold mb-2">Seleccione operación:</label>
            <select id="operationSelect" class="block w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 transition duration-200 ease-in-out">
                <option value="decode">Decodificador</option>
                <option value="denoise">Quitar Ruido (Denoise)</option>
            </select>
        </div>

        <!-- Sección para Quitar Ruido (Denoise) -->
        <div id="denoiseSection" class="main-section hidden">
            <h2 class="text-2xl font-bold text-gray-700 mb-4 text-center">Operación Denoise (Quitar Ruido)</h2>

            <div class="mb-4">
                <h3 class="text-lg font-semibold text-gray-700 mb-2 text-center">Carácter 'F' Original (7x5):</h3>
                <div id="originalFMatrix" class="grid grid-cols-5 gap-0.5 justify-center mx-auto mb-4" style="max-width: 170px;">
                    <!-- La matriz de la letra 'F' original se renderizará aquí -->
                </div>
            </div>

            <div class="mb-6">
                <label for="noiseProb" class="block text-gray-700 text-sm font-semibold mb-2">Probabilidad de Ruido (0.00 - 1.00):</label>
                <input
                    type="number"
                    id="noiseProb"
                    step="0.01"
                    min="0"
                    max="1"
                    value="0.1"
                    class="block w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 transition duration-200 ease-in-out"
                />
            </div>

            <button
                onclick="handleDenoisePrediction()"
                class="w-full bg-gradient-to-r from-blue-500 to-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-md hover:from-blue-600 hover:to-blue-800 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition duration-200 ease-in-out flex items-center justify-center space-x-2"
            >
                <span id="denoiseButtonText">Aplicar Ruido y Denoise</span>
                <div id="denoiseLoadingSpinner" class="spinner hidden"></div>
            </button>
        </div>

        <!-- Sección para Decodificar con gráfico de espacio latente -->
        <div id="decodeSection" class="main-section">
            <h2 class="text-2xl font-bold text-gray-700 mb-4 text-center">Gráfico de Espacio Latente</h2>
            <div id="chart-container" class="mb-6">
                <!-- El SVG de D3.js para el gráfico se renderizará aquí -->
                <svg id="chart-svg" class="w-full" style="height: 400px;"></svg>
            </div>

            <div class="mb-4 grid grid-cols-2 gap-4">
                <div>
                    <label for="manualX" class="block text-gray-700 text-sm font-semibold mb-2">Valor X:</label>
                    <input
                        type="number"
                        id="manualX"
                        step="0.01"
                        placeholder="Ej: 0.5"
                        class="block w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 transition duration-200 ease-in-out"
                    />
                </div>
                <div>
                    <label for="manualY" class="block text-gray-700 text-sm font-semibold mb-2">Valor Y:</label>
                    <input
                        type="number"
                        id="manualY"
                        step="0.01"
                        placeholder="Ej: -0.2"
                        class="block w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500 transition duration-200 ease-in-out"
                    />
                </div>
            </div>

            <button
                onclick="handleDecodePrediction()"
                class="w-full bg-gradient-to-r from-green-500 to-green-700 text-white font-bold py-3 px-4 rounded-lg shadow-md hover:from-green-600 hover:to-green-800 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75 transition duration-200 ease-in-out flex items-center justify-center space-x-2"
            >
                <span id="decodeButtonText">Generar Decodificación</span>
                <div id="decodeLoadingSpinner" class="spinner hidden"></div>
            </button>
        </div>

        <!-- Contenedor para mostrar el resultado de la predicción (Matriz) -->
        <div id="predictionResultSection" class="mt-8 p-6 bg-blue-50 rounded-lg shadow-inner hidden">
            <h2 class="text-xl font-semibold text-blue-800 mb-4 text-center">Resultado de la Predicción</h2>
            <div id="predictionMatrix" class="grid grid-cols-5 gap-0.5 justify-center mx-auto" style="max-width: 170px;">
                <!-- Las celdas de la matriz decodificada se insertarán aquí -->
            </div>
            <p id="predictionPlaceholder" class="text-center text-gray-500 mt-4 hidden">
                El resultado de la predicción se mostrará aquí.
            </p>
        </div>


        <!-- Contenedor para mostrar mensajes de error -->
        <div id="errorContainer" class="mt-8 p-4 bg-red-50 border border-red-200 rounded-lg text-red-800 hidden" role="alert">
            <p id="errorMessage" class="font-medium text-lg"></p>
        </div>

    </div>

    <script>
        // Variables globales para almacenar los pesos del autoencoder
        let pesosAutoencoder = null;
        let pesosRuido = null;

        // Datos de los caracteres y sus coordenadas en el espacio latente
        const labels = ['@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\', ']', '^', '_'];
        const coords = [[0.62, 0.88], [0.01, 0.49], [0.68, 0.72], [0.87, 0.88], [0.0, 0.0], [0.54, 0.47], [0.52, 0.58], [0.99, 0.96], [0.21, 0.78], [0.78, 0.0], [0.93, 0.38], [0.34, 0.49], [0.43, 0.34], [0.13, 0.79], [0.01, 0.97], [0.84, 1.0], [0.56, 0.67], [0.56, 0.95], [0.43, 0.73], [0.84, 0.71], [0.48, 0.0], [0.33, 0.99], [0.27, 0.94], [0.21, 0.83], [0.21, 0.22], [0.35, 0.13], [0.61, 0.36], [0.15, 0.0], [0.23, 0.13], [1.0, 0.31], [0.23, 0.0], [0.44, 0.3]];

        // Combinar las etiquetas y las coordenadas en un formato fácil de usar para D3.js
        const trainingLatentSpaceData = coords.map((coord, index) => ({
            label: labels[index],
            x: coord[0],
            y: coord[1]
        }));

        // La matriz aplanada de la letra 'F' (7x5 = 35 elementos)
        const originalF = [
            1, 1, 1, 1, 1,
            1, 0, 0, 0, 0,
            1, 0, 0, 0, 0,
            1, 1, 1, 1, 1,
            1, 0, 0, 0, 0,
            1, 0, 0, 0, 0,
            1, 0, 0, 0, 0
        ];

        let selectedArbitraryCircle = null; // Variable para almacenar la referencia al círculo de selección arbitraria en D3.js

        /**
         * Inicializa y dibuja el gráfico D3.js para mostrar el espacio latente.
         * Esta función se llama al inicio y cada vez que la ventana se redimensiona
         * para asegurar que el gráfico sea responsivo.
         */
        function initChart() {
            const svg = d3.select("#chart-svg");
            // Definir márgenes para el gráfico dentro del SVG
            const margin = { top: 30, right: 30, bottom: 30, left: 30 };
            // Calcular el ancho y alto del área de trazado del gráfico
            const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = svg.node().getBoundingClientRect().height - margin.top - margin.bottom;

            // Limpia el SVG si ya tiene contenido, evitando duplicados al re-dibujar (importante para redimensionamiento)
            svg.selectAll("*").remove();

            // Crea un grupo (g) dentro del SVG para contener los elementos del gráfico y aplicar transformaciones
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Definir escalas lineales para los ejes X e Y, mapeando los datos a píxeles
            const xScale = d3.scaleLinear()
                .domain([-0.05, 1.05]) // Rango de datos para el eje X, con un pequeño padding
                .range([0, width]); // Rango de píxeles para el eje X

            const yScale = d3.scaleLinear()
                .domain([-0.05, 1.05]) // Rango de datos para el eje Y, con un pequeño padding
                .range([height, 0]); // Rango de píxeles para el eje Y (invertido para que el origen esté abajo a la izquierda)

            // Dibujar los ejes X e Y (sin etiquetas de texto)
            g.append("g")
                .attr("class", "x axis") // Clase para aplicar estilos CSS
                .attr("transform", `translate(0,${height})`) // Posicionar el eje X en la parte inferior
                .call(d3.axisBottom(xScale)); // Generar el eje inferior

            g.append("g")
                .attr("class", "y axis") // Clase para aplicar estilos CSS
                .call(d3.axisLeft(yScale)); // Generar el eje izquierdo

            // NOTA: Se eliminan las etiquetas de los ejes X e Y como se solicitó.
            /*
            g.append("text")
                .attr("class", "axis-label")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom / 1.5)
                .attr("text-anchor", "middle")
                .style("fill", "#475569")
                .style("font-size", "0.9rem")
                .text("Dimensión Latente X");

            g.append("text")
                .attr("class", "axis-label")
                .attr("transform", "rotate(-90)")
                .attr("y", -margin.left / 2)
                .attr("x", -height / 2)
                .attr("text-anchor", "middle")
                .style("fill", "#475569")
                .style("font-size", "0.9rem")
                .text("Dimensión Latente Y");
            */

            // Añadir las etiquetas de los caracteres al gráfico
            const points = g.selectAll(".point-group")
                .data(trainingLatentSpaceData) // Enlazar los datos
                .enter().append("g") // Crear un grupo SVG para cada punto
                .attr("class", "point-group") // Clase para estilos
                .attr("transform", d => `translate(${xScale(d.x)},${yScale(d.y)})`) // Posicionar cada grupo
                .on("click", (event, d) => {
                    // Remover cualquier selección anterior (texto resaltado y círculo arbitrario)
                    g.selectAll(".point-group text").classed("selected-text", false);
                    if (selectedArbitraryCircle) {
                        selectedArbitraryCircle.remove();
                        selectedArbitraryCircle = null;
                    }

                    // Marcar el texto de la etiqueta seleccionada (cambiar color y tamaño)
                    d3.select(event.currentTarget).select("text").classed("selected-text", true);

                    // Actualizar los campos de entrada con las coordenadas del punto clicado
                    document.getElementById('manualX').value = d.x.toFixed(3);
                    document.getElementById('manualY').value = d.y.toFixed(3);
                    // Disparar la decodificación automáticamente al seleccionar un punto
                    handleDecodePrediction();
                });

            // Añadir las etiquetas de texto a cada grupo de puntos
            points.append("text")
                .attr("text-anchor", "middle") // Centrar horizontalmente el texto
                .attr("dominant-baseline", "middle") // Centrar verticalmente el texto
                .text(d => d.label); // Mostrar la etiqueta del carácter

            // Evento de clic en el SVG para deseleccionar puntos o seleccionar un punto arbitrario en el espacio latente
            const chartSvg = document.getElementById('chart-svg');
            chartSvg.addEventListener('click', function(event) {
                // Obtener las coordenadas del clic relativas al elemento 'g' del gráfico
                const [xCoordPixel, yCoordPixel] = d3.pointer(event, g.node());

                // Convertir las coordenadas de píxeles a coordenadas de datos (valores del espacio latente)
                const dataX = xScale.invert(xCoordPixel);
                const dataY = yScale.invert(yCoordPixel);

                // Verificar si el clic no fue dentro de un grupo de puntos existentes (una etiqueta)
                // y si no fue en el círculo arbitrario ya existente
                if (!event.target.closest('.point-group') && !event.target.classList.contains('selected-arbitrary-point')) {
                    // Remover cualquier selección de texto anterior
                    g.selectAll(".point-group text").classed("selected-text", false);
                    // Remover el círculo arbitrario seleccionado anteriormente, si existe
                    if (selectedArbitraryCircle) {
                        selectedArbitraryCircle.remove();
                        selectedArbitraryCircle = null;
                    }

                    // Agregar un nuevo círculo para representar el punto arbitrario seleccionado por el usuario
                    selectedArbitraryCircle = g.append("circle")
                        .attr("class", "selected-arbitrary-point") // Clase para aplicar estilos CSS
                        .attr("cx", xCoordPixel) // Coordenada X en píxeles
                        .attr("cy", yCoordPixel) // Coordenada Y en píxeles
                        .attr("r", 5); // Radio inicial del círculo

                    // Actualizar los campos de entrada con las coordenadas del punto arbitrario
                    document.getElementById('manualX').value = dataX.toFixed(3);
                    document.getElementById('manualY').value = dataY.toFixed(3);
                    // Disparar la decodificación automáticamente
                    handleDecodePrediction();
                } else if (event.target.classList.contains('selected-arbitrary-point')) {
                    // Si se hizo clic en el círculo arbitrario, no hacer nada más que mantenerlo seleccionado
                    // y sus valores ya están en los inputs
                }
            });
        }

        /**
         * Muestra u oculta las secciones de la interfaz de usuario
         * según la operación seleccionada (Decodificador o Quitar Ruido).
         */
        function toggleSections() {
            const operation = document.getElementById('operationSelect').value;
            const denoiseSection = document.getElementById('denoiseSection');
            const decodeSection = document.getElementById('decodeSection');
            const predictionResultSection = document.getElementById('predictionResultSection');

            if (operation === 'denoise') {
                denoiseSection.classList.remove('hidden');
                decodeSection.classList.add('hidden');
                predictionResultSection.classList.add('hidden'); // Ocultar resultados al cambiar a denoise hasta que se haga una predicción
                mostrarMatriz(originalF, "originalFMatrix", 5); // Mostrar la F original
            } else if (operation === 'decode') {
                denoiseSection.classList.add('hidden');
                decodeSection.classList.remove('hidden');
                predictionResultSection.classList.add('hidden'); // Ocultar resultados al cambiar a decode hasta que se haga una predicción
                initChart(); // Reinicializa el gráfico D3.js cuando se muestra la sección de decodificación
            }
            // Limpiar mensajes de error al cambiar de sección
            document.getElementById('errorContainer').classList.add('hidden');
        }

        /**
         * Función sigmoide (activación) para las capas del autoencoder.
         * @param {any} x - Entrada (número o matriz de math.js).
         * @returns {any} Salida de la función sigmoide.
         */
        function sigmoide(x) {
            // math.js se usa para operaciones matriciales seguras
            return math.dotDivide(1, math.add(1, math.exp(math.multiply(-1, x))));
        }

        /**
         * Implementación del decodificador del autoencoder en JavaScript.
         * Corresponde a la función `decoder` de tu código Python.
         * @param {Array<number[]>} V_latente - Vector latente de entrada.
         * @param {Array<number[]>} w3 - Pesos de la tercera capa (primera del decodificador).
         * @param {Array<number[]>} w4 - Pesos de la cuarta capa (segunda del decodificador).
         * @param {Array<number>} b3 - Bias de la tercera capa.
         * @param {Array<number>} b4 - Bias de la cuarta capa.
         * @returns {Array<number[]>} La salida decodificada.
         */
        function decoder(V_latente, w3, w4, b3, b4) {
            // V3 = sigmoide(V_latente @ w3 + b3)
            let V3 = sigmoide(math.add(math.multiply(V_latente, w3), b3));
            // V4 = sigmoide(V3 @ w4 + b4)
            let V4 = sigmoide(math.add(math.multiply(V3, w4), b4));
            return V4;
        }

        /**
         * Implementación de la función de eliminación de ruido (autoencoder completo) en JavaScript.
         * Corresponde a la función `predecir_autoencoder_ruido` de tu código Python.
         * @param {Array<number[]>} Vk - Entrada con ruido.
         * @param {Array<number[]>} w1 - Pesos de la primera capa.
         * @param {Array<number[]>} w2 - Pesos de la segunda capa.
         * @param {Array<number[]>} w3 - Pesos de la tercera capa.
         * @param {Array<number[]>} w4 - Pesos de la cuarta capa.
         * @param {Array<number>} b1 - Bias de la primera capa.
         * @param {Array<number>} b2 - Bias de la segunda capa.
         * @param {Array<number>} b3 - Bias de la tercera capa.
         * @param {Array<number>} b4 - Bias de la cuarta capa.
         * @returns {Array<number[]>} La salida denoised.
         */
        function predecir_autoencoder_ruido(Vk, w1, w2, w3, w4, b1, b2, b3, b4) {
            // Asegúrate de que Vk sea una matriz de math.js si no lo es ya
            const VkMatrix = math.matrix(Vk);

            // V1 = sigmoide(Vk @ w1 + b1)
            let V1 = sigmoide(math.add(math.multiply(VkMatrix, w1), b1));
            // V2 = sigmoide(V1 @ w2 + b2)
            let V2 = sigmoide(math.add(math.multiply(V1, w2), b2));
            // V3 = sigmoide(V2 @ w3 + b3)
            let V3 = sigmoide(math.add(math.multiply(V2, w3), b3));
            // V4 = sigmoide(V3 @ w4 + b4)
            let V4 = sigmoide(math.add(math.multiply(V3, w4), b4));
            return V4;
        }

        /**
         * Agrega ruido binario a una matriz de entrada.
         * @param {Array<number>} x - La matriz original a la que se le agregará ruido (aplanada).
         * @param {number} prob - La probabilidad (entre 0 y 1) de voltear un bit.
         * @returns {Array<number>} La matriz con ruido.
         */
        function agregar_ruido(x, prob = 0.02) {
            // Crear una copia del array para no modificar el original
            const x_ruido = [...x];
            let cambios = 0;

            for (let i = 0; i < x_ruido.length; i++) {
                // Generar un número aleatorio entre 0 y 1
                if (Math.random() < prob) {
                    cambios++;
                    // Voltear el bit: si es 0, se vuelve 1; si es 1, se vuelve 0
                    x_ruido[i] = x_ruido[i] === 0 ? 1 : 0;
                }
            }
            console.log(`Cambios realizados: ${cambios}`);
            return x_ruido;
        }


        /**
         * Muestra una matriz binaria (0s y 1s) como una cuadrícula de celdas.
         * Utilizado para visualizar la salida decodificada/denoised.
         * @param {Array<number>} binaryOutput - Array de 0s y 1s.
         * @param {string} targetElementId - ID del elemento HTML donde se renderizará la matriz.
         * @param {number} cols - Número de columnas para la cuadrícula (ej: 5 para 5x5).
         */
        function mostrarMatriz(binaryOutput, targetElementId, cols = 5) {
            const matrixDiv = document.getElementById(targetElementId);
            if (!matrixDiv) {
                console.error(`Elemento con ID ${targetElementId} no encontrado.`);
                return;
            }

            matrixDiv.innerHTML = ""; // Limpia la matriz anterior
            // matrixDiv.classList.remove('hidden'); // No ocultar/mostrar aquí, se maneja en la sección

            if (binaryOutput.length === 0) {
                matrixDiv.textContent = "No hay datos para mostrar la matriz.";
                return;
            }

            // Establecer el estilo de la cuadrícula dinámicamente
            matrixDiv.style.gridTemplateColumns = `repeat(${cols}, 30px)`; // Ancho de celda de 30px

            binaryOutput.forEach((val) => {
                const cell = document.createElement("div");
                // Aplica clases de Tailwind para el estilo de la celda
                cell.className = `matrix-cell rounded-sm ${val ? "active" : "inactive"}`;
                matrixDiv.appendChild(cell);
            });
        }

        /**
         * Oculta el spinner de carga y restablece el texto del botón.
         * @param {string} buttonTextId - ID del span que contiene el texto del botón.
         * @param {string} spinnerId - ID del spinner.
         * @param {string} defaultButtonText - Texto por defecto del botón.
         * @param {string} parentSectionId - ID de la sección padre para encontrar el botón.
         */
        function hideLoadingState(buttonTextId, spinnerId, defaultButtonText, parentSectionId) {
            const buttonTextSpan = document.getElementById(buttonTextId);
            const spinnerElement = document.getElementById(spinnerId);
            const mainButton = document.querySelector(`#${parentSectionId} button`);

            if (buttonTextSpan) buttonTextSpan.textContent = defaultButtonText;
            if (spinnerElement) spinnerElement.classList.add('hidden');
            if (mainButton) mainButton.disabled = false;
        }

        /**
         * Muestra el spinner de carga y deshabilita el botón.
         * @param {string} buttonTextId - ID del span que contiene el texto del botón.
         * @param {string} spinnerId - ID del spinner.
         * @param {string} parentSectionId - ID de la sección padre para encontrar el botón.
         */
        function showLoadingState(buttonTextId, spinnerId, parentSectionId) {
            const buttonTextSpan = document.getElementById(buttonTextId);
            const spinnerElement = document.getElementById(spinnerId);
            const mainButton = document.querySelector(`#${parentSectionId} button`);

            if (buttonTextSpan) buttonTextSpan.textContent = 'Cargando...';
            if (spinnerElement) spinnerElement.classList.remove('hidden');
            if (mainButton) mainButton.disabled = true;
        }

        /**
         * Muestra un mensaje de error en el contenedor de errores.
         * @param {string} message - El mensaje de error a mostrar.
         */
        function showErrorMessage(message) {
            const errorContainer = document.getElementById('errorContainer');
            const errorMessage = document.getElementById('errorMessage');
            errorMessage.textContent = message;
            errorContainer.classList.remove('hidden');
        }

        /**
         * Oculta el mensaje de error.
         */
        function hideErrorMessage() {
            document.getElementById('errorContainer').classList.add('hidden');
        }

        /**
         * Carga los archivos de pesos del autoencoder desde el directorio local.
         */
        async function cargarPesos() {
            hideErrorMessage(); // Ocultar errores anteriores

            try {
                // Cargar pesos_autoencoder.json (para el decodificador principal)
                const responseAutoencoder = await fetch('pesos_autoencoder.json');
                if (!responseAutoencoder.ok) {
                    throw new Error(`Error al cargar 'pesos_autoencoder.json': ${responseAutoencoder.statusText}`);
                }
                pesosAutoencoder = await responseAutoencoder.json();
                console.log("Pesos Autoencoder cargados:", pesosAutoencoder);

                // Cargar pesos_autoencoder_ruido.json (para la operación de quitar ruido)
                const responseRuido = await fetch('pesos_autoencoder_ruido.json');
                if (!responseRuido.ok) {
                    throw new Error(`Error al cargar 'pesos_autoencoder_ruido.json': ${responseRuido.statusText}`);
                }
                pesosRuido = await responseRuido.json();
                console.log("Pesos Ruido cargados:", pesosRuido);

            } catch (error) {
                showErrorMessage(`No se pudieron cargar los archivos de pesos. Asegúrate de que 'pesos_autoencoder.json' y 'pesos_autoencoder_ruido.json' están en la misma carpeta. Detalle: ${error.message}`);
                console.error("Error al cargar pesos:", error);
                // Si los pesos no se cargan, las operaciones de predicción no funcionarán.
                pesosAutoencoder = null;
                pesosRuido = null;
            }
        }


        /**
         * Maneja la lógica para la operación "Quitar Ruido" (Denoise).
         * Aplica ruido al carácter 'F' y luego lo pasa por el autoencoder para limpiarlo.
         */
        async function handleDenoisePrediction() {
            hideErrorMessage();
            const noiseProb = parseFloat(document.getElementById('noiseProb').value);

            if (!pesosRuido) {
                showErrorMessage("Los pesos para la operación de quitar ruido no se han cargado. Recarga la página o verifica los archivos JSON.");
                return;
            }

            // Validar la probabilidad de ruido
            if (isNaN(noiseProb) || noiseProb < 0 || noiseProb > 1) {
                showErrorMessage('La probabilidad de ruido debe ser un número entre 0 y 1.');
                return;
            }

            // Mostrar estado de carga
            showLoadingState('denoiseButtonText', 'denoiseLoadingSpinner', 'denoiseSection');
            const predictionResultSection = document.getElementById("predictionResultSection");
            const predictionPlaceholder = document.getElementById("predictionPlaceholder");
            const predictionMatrix = document.getElementById("predictionMatrix");

            // Ocultar resultados anteriores y placeholder
            predictionResultSection.classList.add('hidden');
            predictionMatrix.classList.add('hidden');
            predictionPlaceholder.classList.add('hidden');


            try {
                // 1. Aplicar ruido al carácter 'F' original
                const noisyF = agregar_ruido(originalF, noiseProb);

                // 2. Convertir la entrada con ruido a una matriz de math.js (debe ser 2D)
                const Vk = math.matrix([noisyF]);

                // 3. Realizar la predicción de eliminación de ruido localmente
                const outputV4 = predecir_autoencoder_ruido(
                    Vk,
                    math.matrix(pesosRuido.w1),
                    math.matrix(pesosRuido.w2),
                    math.matrix(pesosRuido.w3),
                    math.matrix(pesosRuido.w4),
                    math.matrix(pesosRuido.b1),
                    math.matrix(pesosRuido.b2),
                    math.matrix(pesosRuido.b3),
                    math.matrix(pesosRuido.b4)
                );

                // 4. Convertir la salida de math.js a un array plano y luego a binario (0 o 1)
                const binaryOutput = outputV4.toArray()[0].map(v => v > 0.5 ? 1 : 0);

                // 5. Mostrar la matriz denoised en la sección de resultados
                mostrarMatriz(binaryOutput, "predictionMatrix", 5); // Suponemos una matriz de 5 columnas
                predictionResultSection.classList.remove('hidden'); // Mostrar la sección de resultados

            } catch (error) {
                showErrorMessage(`Error durante la predicción de Denoise: ${error.message}`);
                console.error("Error en la predicción Denoise:", error);
            } finally {
                // Ocultar estado de carga
                hideLoadingState('denoiseButtonText', 'denoiseLoadingSpinner', 'Predecir', 'denoiseSection');
            }
        }

        /**
         * Maneja la lógica para la operación "Decodificador".
         * Obtiene los valores X e Y de los inputs y realiza la decodificación localmente.
         */
        async function handleDecodePrediction() {
            hideErrorMessage();
            const manualX = document.getElementById('manualX').value;
            const manualY = document.getElementById('manualY').value;

            if (!pesosAutoencoder) {
                showErrorMessage("Los pesos para la operación de decodificación no se han cargado. Recarga la página o verifica los archivos JSON.");
                return;
            }

            // Mostrar estado de carga
            showLoadingState('decodeButtonText', 'decodeLoadingSpinner', 'decodeSection');
            const predictionResultSection = document.getElementById("predictionResultSection");
            const predictionPlaceholder = document.getElementById("predictionPlaceholder");
            const predictionMatrix = document.getElementById("predictionMatrix");


            // Ocultar resultados anteriores y placeholder
            predictionResultSection.classList.add('hidden');
            predictionMatrix.classList.add('hidden');
            predictionPlaceholder.classList.add('hidden');


            try {
                // Validar entrada
                if (manualX === '' || manualY === '' || isNaN(Number(manualX)) || isNaN(Number(manualY))) {
                    showErrorMessage('Por favor, ingrese valores X e Y válidos para decodificar (números).');
                    return;
                }

                // Crear el vector latente de entrada como una matriz de math.js
                const V_latente = math.matrix([[Number(manualX), Number(manualY)]]);

                // Realizar la decodificación localmente
                const salida = decoder(
                    V_latente,
                    math.matrix(pesosAutoencoder.w3),
                    math.matrix(pesosAutoencoder.w4),
                    math.matrix(pesosAutoencoder.b3),
                    math.matrix(pesosAutoencoder.b4)
                );

                // Convertir la salida de math.js a un array plano y luego a binario
                const binaryOutput = salida.toArray()[0].map(v => v > 0.5 ? 1 : 0);

                // Mostrar la matriz decodificada
                mostrarMatriz(binaryOutput, "predictionMatrix", 5); // Suponemos una matriz de 5 columnas
                predictionResultSection.classList.remove('hidden'); // Mostrar la sección de resultados

            } catch (error) {
                showErrorMessage(`Error durante la decodificación: ${error.message}`);
                console.error("Error en la decodificación:", error);
            } finally {
                // Ocultar estado de carga
                hideLoadingState('decodeButtonText', 'decodeLoadingSpinner', 'Generar Decodificación', 'decodeSection');
            }
        }

        // Escuchar cambios en el selector de operación para mostrar la sección correcta
        document.getElementById('operationSelect').addEventListener('change', toggleSections);

        // Al cargar la página, cargamos los pesos y luego inicializamos la vista.
        document.addEventListener('DOMContentLoaded', async () => {
            await cargarPesos(); // Espera a que los pesos se carguen antes de continuar
            toggleSections(); // Inicializa la vista según la operación seleccionada
        });

        // Volver a dibujar el gráfico si la ventana se redimensiona, para asegurar que sea responsivo
        window.addEventListener('resize', () => {
            if (document.getElementById('operationSelect').value === 'decode') {
                initChart();
            }
        });
    </script>
</body>
</html>
